!function (e) {
    if ("object" == typeof exports) module.exports = e(); else if ("function" == typeof define && define.amd) define(e); else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.PF = e()
    }
}(function () {
    var define, module, exports;
    return (function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a)return a(o, !0);
                    if (i)return i(o, !0);
                    throw new Error("Cannot find module '" + o + "'")
                }
                var f = n[o] = {exports: {}};
                t[o][0].call(f.exports, function (e) {
                    var n = t[o][1][e];
                    return s(n ? n : e)
                }, f, f.exports, e, t, n, r)
            }
            return n[o].exports
        }

        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++)s(r[o]);
        return s
    })({
        1: [function (_dereq_, module, exports) {
            module.exports = _dereq_('./lib/heap');

        }, {"./lib/heap": 2}],
        2: [function (_dereq_, module, exports) {
// Generated by CoffeeScript 1.8.0
            (function () {
                var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

                floor = Math.floor, min = Math.min;


                /*
                 Default comparison function to be used
                 */

                defaultCmp = function (x, y) {
                    if (x < y) {
                        return -1;
                    }
                    if (x > y) {
                        return 1;
                    }
                    return 0;
                };


                /*
                 Insert item x in list a, and keep it sorted assuming a is sorted.

                 If x is already in a, insert it to the right of the rightmost x.

                 Optional args lo (default 0) and hi (default a.length) bound the slice
                 of a to be searched.
                 */

                insort = function (a, x, lo, hi, cmp) {
                    var mid;
                    if (lo == null) {
                        lo = 0;
                    }
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    if (lo < 0) {
                        throw new Error('lo must be non-negative');
                    }
                    if (hi == null) {
                        hi = a.length;
                    }
                    while (lo < hi) {
                        mid = floor((lo + hi) / 2);
                        if (cmp(x, a[mid]) < 0) {
                            hi = mid;
                        } else {
                            lo = mid + 1;
                        }
                    }
                    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
                };


                /*
                 Push item onto heap, maintaining the heap invariant.
                 */

                heappush = function (array, item, cmp) {
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    array.push(item);
                    return _siftdown(array, 0, array.length - 1, cmp);
                };


                /*
                 Pop the smallest item off the heap, maintaining the heap invariant.
                 */

                heappop = function (array, cmp) {
                    var lastelt, returnitem;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    lastelt = array.pop();
                    if (array.length) {
                        returnitem = array[0];
                        array[0] = lastelt;
                        _siftup(array, 0, cmp);
                    } else {
                        returnitem = lastelt;
                    }
                    return returnitem;
                };


                /*
                 Pop and return the current smallest value, and add the new item.

                 This is more efficient than heappop() followed by heappush(), and can be
                 more appropriate when using a fixed size heap. Note that the value
                 returned may be larger than item! That constrains reasonable use of
                 this routine unless written as part of a conditional replacement:
                 if item > array[0]
                 item = heapreplace(array, item)
                 */

                heapreplace = function (array, item, cmp) {
                    var returnitem;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    returnitem = array[0];
                    array[0] = item;
                    _siftup(array, 0, cmp);
                    return returnitem;
                };


                /*
                 Fast version of a heappush followed by a heappop.
                 */

                heappushpop = function (array, item, cmp) {
                    var _ref;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    if (array.length && cmp(array[0], item) < 0) {
                        _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
                        _siftup(array, 0, cmp);
                    }
                    return item;
                };


                /*
                 Transform list into a heap, in-place, in O(array.length) time.
                 */

                heapify = function (array, cmp) {
                    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    _ref1 = (function () {
                        _results1 = [];
                        for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--) {
                            _results1.push(_j);
                        }
                        return _results1;
                    }).apply(this).reverse();
                    _results = [];
                    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                        i = _ref1[_i];
                        _results.push(_siftup(array, i, cmp));
                    }
                    return _results;
                };


                /*
                 Update the position of the given item in the heap.
                 This function should be called every time the item is being modified.
                 */

                updateItem = function (array, item, cmp) {
                    var pos;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    pos = array.indexOf(item);
                    if (pos === -1) {
                        return;
                    }
                    _siftdown(array, 0, pos, cmp);
                    return _siftup(array, pos, cmp);
                };


                /*
                 Find the n largest elements in a dataset.
                 */

                nlargest = function (array, n, cmp) {
                    var elem, result, _i, _len, _ref;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    result = array.slice(0, n);
                    if (!result.length) {
                        return result;
                    }
                    heapify(result, cmp);
                    _ref = array.slice(n);
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        elem = _ref[_i];
                        heappushpop(result, elem, cmp);
                    }
                    return result.sort(cmp).reverse();
                };


                /*
                 Find the n smallest elements in a dataset.
                 */

                nsmallest = function (array, n, cmp) {
                    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    if (n * 10 <= array.length) {
                        result = array.slice(0, n).sort(cmp);
                        if (!result.length) {
                            return result;
                        }
                        los = result[result.length - 1];
                        _ref = array.slice(n);
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            elem = _ref[_i];
                            if (cmp(elem, los) < 0) {
                                insort(result, elem, 0, null, cmp);
                                result.pop();
                                los = result[result.length - 1];
                            }
                        }
                        return result;
                    }
                    heapify(array, cmp);
                    _results = [];
                    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                        _results.push(heappop(array, cmp));
                    }
                    return _results;
                };

                _siftdown = function (array, startpos, pos, cmp) {
                    var newitem, parent, parentpos;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    newitem = array[pos];
                    while (pos > startpos) {
                        parentpos = (pos - 1) >> 1;
                        parent = array[parentpos];
                        if (cmp(newitem, parent) < 0) {
                            array[pos] = parent;
                            pos = parentpos;
                            continue;
                        }
                        break;
                    }
                    return array[pos] = newitem;
                };

                _siftup = function (array, pos, cmp) {
                    var childpos, endpos, newitem, rightpos, startpos;
                    if (cmp == null) {
                        cmp = defaultCmp;
                    }
                    endpos = array.length;
                    startpos = pos;
                    newitem = array[pos];
                    childpos = 2 * pos + 1;
                    while (childpos < endpos) {
                        rightpos = childpos + 1;
                        if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
                            childpos = rightpos;
                        }
                        array[pos] = array[childpos];
                        pos = childpos;
                        childpos = 2 * pos + 1;
                    }
                    array[pos] = newitem;
                    return _siftdown(array, startpos, pos, cmp);
                };

                Heap = (function () {
                    Heap.push = heappush;

                    Heap.pop = heappop;

                    Heap.replace = heapreplace;

                    Heap.pushpop = heappushpop;

                    Heap.heapify = heapify;

                    Heap.updateItem = updateItem;

                    Heap.nlargest = nlargest;

                    Heap.nsmallest = nsmallest;

                    function Heap(cmp) {
                        this.cmp = cmp != null ? cmp : defaultCmp;
                        this.nodes = [];
                    }

                    Heap.prototype.push = function (x) {
                        return heappush(this.nodes, x, this.cmp);
                    };

                    Heap.prototype.pop = function () {
                        return heappop(this.nodes, this.cmp);
                    };

                    Heap.prototype.peek = function () {
                        return this.nodes[0];
                    };

                    Heap.prototype.contains = function (x) {
                        return this.nodes.indexOf(x) !== -1;
                    };

                    Heap.prototype.replace = function (x) {
                        return heapreplace(this.nodes, x, this.cmp);
                    };

                    Heap.prototype.pushpop = function (x) {
                        return heappushpop(this.nodes, x, this.cmp);
                    };

                    Heap.prototype.heapify = function () {
                        return heapify(this.nodes, this.cmp);
                    };

                    Heap.prototype.updateItem = function (x) {
                        return updateItem(this.nodes, x, this.cmp);
                    };

                    Heap.prototype.clear = function () {
                        return this.nodes = [];
                    };

                    Heap.prototype.empty = function () {
                        return this.nodes.length === 0;
                    };

                    Heap.prototype.size = function () {
                        return this.nodes.length;
                    };

                    Heap.prototype.clone = function () {
                        var heap;
                        heap = new Heap();
                        heap.nodes = this.nodes.slice(0);
                        return heap;
                    };

                    Heap.prototype.toArray = function () {
                        return this.nodes.slice(0);
                    };

                    Heap.prototype.insert = Heap.prototype.push;

                    Heap.prototype.top = Heap.prototype.peek;

                    Heap.prototype.front = Heap.prototype.peek;

                    Heap.prototype.has = Heap.prototype.contains;

                    Heap.prototype.copy = Heap.prototype.clone;

                    return Heap;

                })();

                if (typeof module !== "undefined" && module !== null ? module.exports : void 0) {
                    module.exports = Heap;
                } else {
                    window.Heap = Heap;
                }

            }).call(this);

        }, {}],
        3: [function (_dereq_, module, exports) {
            var DiagonalMovement = {
                Always: 1,
                Never: 2,
                IfAtMostOneObstacle: 3,
                OnlyWhenNoObstacles: 4
            };

            module.exports = DiagonalMovement;
        }, {}],
        4: [function (_dereq_, module, exports) {
            var Node = _dereq_('./Node');
            var DiagonalMovement = _dereq_('./DiagonalMovement');

            /**
             * The Grid class, which serves as the encapsulation of the layout of the nodes.
             * @constructor
             * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix
             * @param {number} height Number of rows of the grid.
             * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix
             *     representing the walkable status of the nodes(0 or false for walkable).
             *     If the matrix is not supplied, all the nodes will be walkable.  */
            function Grid(width_or_matrix, height, matrix) {
                var width;

                if (typeof width_or_matrix !== 'object') {
                    width = width_or_matrix;
                } else {
                    height = width_or_matrix.length;
                    width = width_or_matrix[0].length;
                    matrix = width_or_matrix;
                }

                /**
                 * The number of columns of the grid.
                 * @type number
                 */
                this.width = width;
                /**
                 * The number of rows of the grid.
                 * @type number
                 */
                this.height = height;

                /**
                 * A 2D array of nodes.
                 */
                this.nodes = this._buildNodes(width, height, matrix);
            }

            /**
             * Build and return the nodes.
             * @private
             * @param {number} width
             * @param {number} height
             * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing
             *     the walkable status of the nodes.
             * @see Grid
             */
            Grid.prototype._buildNodes = function (width, height, matrix) {
                var i, j,
                    nodes = new Array(height);

                for (i = 0; i < height; ++i) {
                    nodes[i] = new Array(width);
                    for (j = 0; j < width; ++j) {
                        nodes[i][j] = new Node(j, i);
                    }
                }


                if (matrix === undefined) {
                    return nodes;
                }

                if (matrix.length !== height || matrix[0].length !== width) {
                    throw new Error('Matrix size does not fit');
                }

                for (i = 0; i < height; ++i) {
                    for (j = 0; j < width; ++j) {
                        if (matrix[i][j]) {
                            // 0, false, null will be walkable
                            // while others will be un-walkable
                            nodes[i][j].walkable = false;
                        }
                    }
                }

                return nodes;
            };


            Grid.prototype.getNodeAt = function (x, y) {
                return this.nodes[y][x];
            };



            Grid.prototype.isWalkableAt = function (x, y) {
                return this.isInside(x, y) && this.nodes[y][x].walkable;
            };



            Grid.prototype.isInside = function (x, y) {
                return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);
            };



            Grid.prototype.setWalkableAt = function (x, y, walkable) {
                this.nodes[y][x].walkable = walkable;
            };



            Grid.prototype.getNeighbors = function (node, diagonalMovement) {
                var x = node.x,
                    y = node.y,
                    neighbors = [],
                    s0 = false, d0 = false,
                    s1 = false, d1 = false,
                    s2 = false, d2 = false,
                    s3 = false, d3 = false,
                    nodes = this.nodes;

                // ↑
                if (this.isWalkableAt(x, y - 1)) {
                    neighbors.push(nodes[y - 1][x]);
                    s0 = true;
                }
                // →
                if (this.isWalkableAt(x + 1, y)) {
                    neighbors.push(nodes[y][x + 1]);
                    s1 = true;
                }
                // ↓
                if (this.isWalkableAt(x, y + 1)) {
                    neighbors.push(nodes[y + 1][x]);
                    s2 = true;
                }
                // ←
                if (this.isWalkableAt(x - 1, y)) {
                    neighbors.push(nodes[y][x - 1]);
                    s3 = true;
                }



                return neighbors;
            };


            /**
             * Get a clone of this grid.
             * @return {Grid} Cloned grid.
             */
            Grid.prototype.clone = function () {
                var i, j,

                    width = this.width,
                    height = this.height,
                    thisNodes = this.nodes,

                    newGrid = new Grid(width, height),
                    newNodes = new Array(height);

                for (i = 0; i < height; ++i) {
                    newNodes[i] = new Array(width);
                    for (j = 0; j < width; ++j) {
                        newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);
                    }
                }

                newGrid.nodes = newNodes;

                return newGrid;
            };

            module.exports = Grid;

        }, {"./DiagonalMovement": 3, "./Node": 6}],
        5: [function (_dereq_, module, exports) {
            /**
             * @namespace PF.Heuristic
             * @description A collection of heuristic functions.
             */
            module.exports = {



            };

        }, {}],
        6: [function (_dereq_, module, exports) {
            /**
             * A node in grid.
             * This class holds some basic information about a node and custom
             * attributes may be added, depending on the algorithms' needs.
             * @constructor
             * @param {number} x - The x coordinate of the node on the grid.
             * @param {number} y - The y coordinate of the node on the grid.
             * @param {boolean} [walkable] - Whether this node is walkable.
             */
            function Node(x, y, walkable) {
                /**
                 * The x coordinate of the node on the grid.
                 * @type number
                 */
                this.x = x;
                /**
                 * The y coordinate of the node on the grid.
                 * @type number
                 */
                this.y = y;
                /**
                 * Whether this node can be walked through.
                 * @type boolean
                 */
                this.walkable = (walkable === undefined ? true : walkable);
            }

            module.exports = Node;

        }, {}],
        7: [function (_dereq_, module, exports) {
            /**
             * Backtrace according to the parent records and return the path.
             * (including both start and end nodes)
             * @param {Node} node End node
             * @return {Array<Array<number>>} the path
             */
            // function backtrace(node) {
            //     var path = [[node.x, node.y]];
            //     while (node.parent) {
            //         node = node.parent;
            //         path.push([node.x, node.y]);
            //     }
            //     return path.reverse();
            // }
            function backtrace(paths) {
                var pathss=[];
                for (var j=0;j<paths.length;j++) {

                    var temp=paths[j];

                    var path = [[temp[0].x, temp[0].y]];
                    for (var i = 1; i < temp.length; i++) {
                        path.push([temp[i].x, temp[i].y]);
                    }
                    pathss.push(path);
                }

                return pathss;
            }
            exports.backtrace = backtrace;

            /**
             * Backtrace from start and end node, and return the path.
             * (including both start and end nodes)
             * @param {Node}
             * @param {Node}
             */
            function biBacktrace(nodeA, nodeB) {
                var pathA = backtrace(nodeA),
                    pathB = backtrace(nodeB);
                return pathA.concat(pathB.reverse());
            }

            exports.biBacktrace = biBacktrace;

            /**
             * Compute the length of the path.
             * @param {Array<Array<number>>} path The path
             * @return {number} The length of the path
             */
            function pathLength(paths) {
                var length=[];
                var i,j, sum = 0, a, b, dx, dy;
                for (j = 0; j < paths.length; ++j) {
                    var path=paths[j];
                    for (i = 1; i < path.length; ++i) {
                        a = path[i - 1];
                        b = path[i];
                        dx = a[0] - b[0];
                        dy = a[1] - b[1];
                        sum += Math.sqrt(dx * dx + dy * dy);
                    }
                    length.push(sum);
                }
                return length;
            }

            exports.pathLength = pathLength;


            /**
             * Given the start and end coordinates, return all the coordinates lying
             * on the line formed by these coordinates, based on Bresenham's algorithm.
             * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification
             * @param {number} x0 Start x coordinate
             * @param {number} y0 Start y coordinate
             * @param {number} x1 End x coordinate
             * @param {number} y1 End y coordinate
             * @return {Array<Array<number>>} The coordinates on the line
             */
            function interpolate(x0, y0, x1, y1) {
                var abs = Math.abs,
                    line = [],
                    sx, sy, dx, dy, err, e2;

                dx = abs(x1 - x0);
                dy = abs(y1 - y0);

                sx = (x0 < x1) ? 1 : -1;
                sy = (y0 < y1) ? 1 : -1;

                err = dx - dy;

                while (true) {
                    line.push([x0, y0]);

                    if (x0 === x1 && y0 === y1) {
                        break;
                    }

                    e2 = 2 * err;
                    if (e2 > -dy) {
                        err = err - dy;
                        x0 = x0 + sx;
                    }
                    if (e2 < dx) {
                        err = err + dx;
                        y0 = y0 + sy;
                    }
                }

                return line;
            }

            exports.interpolate = interpolate;


            /**
             * Given a compressed path, return a new path that has all the segments
             * in it interpolated.
             * @param {Array<Array<number>>} path The path
             * @return {Array<Array<number>>} expanded path
             */
            // function expandPath(path) {
            //     var expanded = [],
            //         len = path.length,
            //         coord0, coord1,
            //         interpolated,
            //         interpolatedLen,
            //         i, j;
            //
            //     if (len < 2) {
            //         return expanded;
            //     }
            //
            //     for (i = 0; i < len - 1; ++i) {
            //         coord0 = path[i];
            //         coord1 = path[i + 1];
            //
            //         interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);
            //         interpolatedLen = interpolated.length;
            //         for (j = 0; j < interpolatedLen - 1; ++j) {
            //             expanded.push(interpolated[j]);
            //         }
            //     }
            //     expanded.push(path[len - 1]);
            //
            //     return expanded;
            // }
            //
            // exports.expandPath = expandPath;


            /**
             * Smoothen the give path.
             * The original path will not be modified; a new path will be returned.
             * @param {PF.Grid} grid
             * @param {Array<Array<number>>} path The path
             */
            function smoothenPath(grid, path) {
                var len = path.length,
                    x0 = path[0][0],        // path start x
                    y0 = path[0][1],        // path start y
                    x1 = path[len - 1][0],  // path end x
                    y1 = path[len - 1][1],  // path end y
                    sx, sy,                 // current start coordinate
                    ex, ey,                 // current end coordinate
                    newPath,
                    i, j, coord, line, testCoord, blocked;

                sx = x0;
                sy = y0;
                newPath = [[sx, sy]];

                for (i = 2; i < len; ++i) {
                    coord = path[i];
                    ex = coord[0];
                    ey = coord[1];
                    line = interpolate(sx, sy, ex, ey);

                    blocked = false;
                    for (j = 1; j < line.length; ++j) {
                        testCoord = line[j];

                        if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
                            blocked = true;
                            break;
                        }
                    }
                    if (blocked) {
                        lastValidCoord = path[i - 1];
                        newPath.push(lastValidCoord);
                        sx = lastValidCoord[0];
                        sy = lastValidCoord[1];
                    }
                }
                newPath.push([x1, y1]);

                return newPath;
            }

            exports.smoothenPath = smoothenPath;


            /**
             * Compress a path, remove redundant nodes without altering the shape
             * The original path is not modified
             * @param {Array<Array<number>>} path The path
             * @return {Array<Array<number>>} The compressed path
             */
            function compressPath(path) {

                // nothing to compress
                if (path.length < 3) {
                    return path;
                }

                var compressed = [],
                    sx = path[0][0], // start x
                    sy = path[0][1], // start y
                    px = path[1][0], // second point x
                    py = path[1][1], // second point y
                    dx = px - sx, // direction between the two points
                    dy = py - sy, // direction between the two points
                    lx, ly,
                    ldx, ldy,
                    sq, i;

                // normalize the direction
                sq = Math.sqrt(dx * dx + dy * dy);
                dx /= sq;
                dy /= sq;

                // start the new path
                compressed.push([sx, sy]);

                for (i = 2; i < path.length; i++) {

                    // store the last point
                    lx = px;
                    ly = py;

                    // store the last direction
                    ldx = dx;
                    ldy = dy;

                    // next point
                    px = path[i][0];
                    py = path[i][1];

                    // next direction
                    dx = px - lx;
                    dy = py - ly;

                    // normalize
                    sq = Math.sqrt(dx * dx + dy * dy);
                    dx /= sq;
                    dy /= sq;

                    // if the direction has changed, store the point
                    if (dx !== ldx || dy !== ldy) {
                        compressed.push([lx, ly]);
                    }
                }

                // store the last point
                compressed.push([px, py]);

                return compressed;
            }

            exports.compressPath = compressPath;

        }, {}],
        8: [function (_dereq_, module, exports) {
            module.exports = {
                'Heap': _dereq_('heap'),
                'Node': _dereq_('./core/Node'),
                'Grid': _dereq_('./core/Grid'),
                'Util': _dereq_('./core/Util'),
                'DiagonalMovement': _dereq_('./core/DiagonalMovement'),
                'Heuristic': _dereq_('./core/Heuristic'),
                'agentAdder': _dereq_('./finders/agentAdder'),
                'DepthFirstChecker': _dereq_('./finders/DepthFirstChecker'),

                'DepthFirstFinder': _dereq_('./finders/DepthFirstFinder'),

                'RegionSeparater': _dereq_('./finders/RegionSeparater'),
            };

        }, {
            "./core/DiagonalMovement": 3,
            "./core/Grid": 4,
            "./core/Heuristic": 5,
            "./core/Node": 6,
            "./core/Util": 7,
            "./finders/agentAdder": 13,

            "./finders/DepthFirstFinder": 15,
            "./finders/DepthFirstChecker": 14,
            "./finders/RegionSeparater": 12,
            "heap": 1
        }],
        12: [function (_dereq_, module, exports) {
            var Util = _dereq_('../core/Util');
            var DiagonalMovement = _dereq_('../core/DiagonalMovement');


            function RegionSeparater(opt) {
                opt = opt || {};
                this.allowDiagonal = opt.allowDiagonal;
                this.dontCrossCorners = opt.dontCrossCorners;
                this.diagonalMovement = opt.diagonalMovement;

                if (!this.diagonalMovement) {
                    if (!this.allowDiagonal) {
                        this.diagonalMovement = DiagonalMovement.Never;
                    } else {
                        if (this.dontCrossCorners) {
                            this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                        } else {
                            this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                        }
                    }
                }
            }

            function getaOpenGrid(grid) {

                for (var j=0;j<grid.height;j++){
                    for (var i=0;i<grid.width;i++){
                        if(!grid.nodes[j][i].closed&&grid.isWalkableAt(i, j)){
                            return grid.nodes[j][i];
                        }
                    }}
                return null;
            }

            RegionSeparater.prototype.search = function (grid2) {

                var regions=[];
                var sp=[];
                grid2.nodes[0][0].closed=false;
                grid2.setWalkableAt(0, 0,true);
                while (getaOpenGrid(grid2)){
                    var node=getaOpenGrid(grid2);
                    var openList = [],
                        startNode = node,
                        neighbors, neighbor, i, l;

                    var path = [];
                    openList.push(startNode);
                    path.push(startNode);
                    sp.push(node);
                    while (openList.length) {
                        node = openList.pop();
                        openList.push(node);
                        path.push(node);
                        node.closed = true;
                        var flag=false;

                        neighbors = grid2.getNeighbors(node, 2);
                        for (i = 0; i < neighbors.length; i++) {
                            neighbor = neighbors[i];

                            if (neighbor.closed) {
                                continue;
                            }
                            openList.push(neighbor);
                            // neighbor.opened = true;
                            neighbor.parent = node;
                            flag=true;
                            break;
                        }
                        if(!flag){
                            openList.pop();
                        }
                    }
                    regions.push(path);
                    // var s="";
                    //
                    //     for (var b = 0; b < path.length; b++) {
                    //         s += "(" + path[b].x + "," + path[b].y + "),"
                    //     }
                    //     alert(s);
                    //     s="";

                }
                return regions;

            };

            module.exports = RegionSeparater;

        }, {"../core/DiagonalMovement": 3, "../core/Util": 7,"./finders/DepthFirstChecker": 14}],



        13: [function (_dereq_, module, exports) {
            var Util = _dereq_('../core/Util');
            var DiagonalMovement = _dereq_('../core/DiagonalMovement');


            function agentAdder(opt) {
                opt = opt || {};
                this.allowDiagonal = opt.allowDiagonal;
                this.dontCrossCorners = opt.dontCrossCorners;
                this.diagonalMovement = opt.diagonalMovement;

                if (!this.diagonalMovement) {
                    if (!this.allowDiagonal) {
                        this.diagonalMovement = DiagonalMovement.Never;
                    } else {
                        if (this.dontCrossCorners) {
                            this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                        } else {
                            this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                        }
                    }
                }
            }

            function getaOpenGrid(grid) {

                for (var j=0;j<grid.height;j++){
                    for (var i=0;i<grid.width;i++){
                        if(!grid.nodes[j][i].closed&&grid.isWalkableAt(i, j)){
                            return grid.nodes[j][i];
                        }
                    }}
                return null;
            }

            agentAdder.prototype.add = function (startX, startY, grid2,checker) {
                var addStart=[];

                var g=getaOpenGrid(grid2);

                if(g){
                    addStart.push(g);
                    startX.push(g.x);
                    startY.push(g.y);

                }
                while (!checker.check(startX,startY,grid2)){
                  g=getaOpenGrid(grid2);


                    if(g){
                     addStart.push(g);
                     startX.push(g.x);
                     startY.push(g.y);

                 }}
                 return addStart;
            };

            module.exports = agentAdder;

        }, {"../core/DiagonalMovement": 3, "../core/Util": 7,"./finders/DepthFirstChecker": 14}],


        14: [function (_dereq_, module, exports) {
            var Util = _dereq_('../core/Util');
            var DiagonalMovement = _dereq_('../core/DiagonalMovement');


            function DepthFirstChecker(opt) {
                opt = opt || {};
                this.allowDiagonal = opt.allowDiagonal;
                this.dontCrossCorners = opt.dontCrossCorners;
                this.diagonalMovement = opt.diagonalMovement;

                if (!this.diagonalMovement) {
                    if (!this.allowDiagonal) {
                        this.diagonalMovement = DiagonalMovement.Never;
                    } else {
                        if (this.dontCrossCorners) {
                            this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                        } else {
                            this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                        }
                    }
                }
            }
            function hasOpenGrid(grid) {

                for (var j=0;j<grid.height;j++){
                    for (var i=0;i<grid.width;i++){
                        if(!grid.nodes[j][i].closed&&grid.isWalkableAt(i, j)){
                            return true;
                        }
                    }}
                return false;
            }


            DepthFirstChecker.prototype.check = function (startX, startY, grid2) {

                for (var a=0;a<startX.length;a++){
                    grid2.getNodeAt(startX[a], startY[a]).closed=true;
                }
                for (var j=0;j<startX.length;j++){
                    var openList = [],
                        startNode = grid2.getNodeAt(startX[j], startY[j]),

                        neighbors, neighbor, node, i, l;

                    var path = [];
                    openList.push(startNode);
                    path.push(startNode);


                    while (openList.length) {
                        node = openList.pop();
                        openList.push(node);
                        path.push(node);
                        node.closed = true;
                        var flag=false;

                        neighbors = grid2.getNeighbors(node, 2);
                        for (i = 0; i < neighbors.length; i++) {
                            neighbor = neighbors[i];

                            if (neighbor.closed) {
                                continue;
                            }
                            openList.push(neighbor);
                            // neighbor.opened = true;
                            neighbor.parent = node;
                            flag=true;
                            break;
                        }
                        if(!flag){
                            openList.pop();
                        }
                    }
                }

                return !hasOpenGrid(grid2);
            };

            module.exports = DepthFirstChecker;

        }, {"../core/DiagonalMovement": 3, "../core/Util": 7}],



        15: [function (_dereq_, module, exports) {
            var Util = _dereq_('../core/Util');
            var DiagonalMovement = _dereq_('../core/DiagonalMovement');


            function DepthFirstFinder(opt) {
                opt = opt || {};
                this.allowDiagonal = opt.allowDiagonal;
                this.dontCrossCorners = opt.dontCrossCorners;
                this.diagonalMovement = opt.diagonalMovement;

                if (!this.diagonalMovement) {
                    if (!this.allowDiagonal) {
                        this.diagonalMovement = DiagonalMovement.Never;
                    } else {
                        if (this.dontCrossCorners) {
                            this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                        } else {
                            this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                        }
                    }
                }
            }
            function hasOpenGrid(grid) {

                    for (var j=0;j<grid.height;j++){
                        for (var i=0;i<grid.width;i++){
                    if(!grid.nodes[j][i].closed&&grid.isWalkableAt(i, j)){
                        return true;
                    }
                }}
                return false;
            }
            function isAllEmpty(lists) {

                for (var j=0;j<lists.height;j++){

                        if(lists[j].length){
                            return false;
                        }
                    }
                return true;
            }


            DepthFirstFinder.prototype.findPath = function (startX, startY, grid) {

                var paths=[];
                var openLists = [];
                for (var a=0;a<startX.length;a++){
                    var startNode = grid.getNodeAt(startX[a], startY[a]);
                    startNode.closed=true;
                   startNode.tag=a+1;
                    var path = [];
                    var openList = [];
                    openList.push(startNode);
                    path.push(startNode);
                    openLists.push(openList);
                    paths.push(path);
                }
                while (hasOpenGrid(grid)) {
                    for (var j = 0; j < startX.length; j++) {
                        var neighbors, neighbor, node, i, l;

                        if (!openLists[j].length) {
                            continue;
                        }
                        node = openLists[j].pop();
                         if(node.tag&&node.tag!=j+1){
                             continue;
                         }
                         node.tag=j+1;
                        openLists[j].push(node);
                        paths[j].push(node);
                        node.closed = true;
                        var flag = false;

                        neighbors = grid.getNeighbors(node, 2);
                        for (i = 0; i < neighbors.length; i++) {
                            neighbor = neighbors[i];

                            if (neighbor.closed) {
                                continue;
                            }

                            if(neighbor.tag&&neighbor.tag!=j+1){
                                continue;
                            }
                            neighbor.tag=j+1;
                            openLists[j].push(neighbor);

                            // neighbor.opened = true;
                            //neighbor.parent = node;
                            flag = true;
                            break;
                        }
                        if (!flag) {
                            openLists[j].pop();
                        }
                    }

                }
               // Util.backtrace();

                // var s="";
                // for(var b=0;b<path.length;b++){
                //     s+="("+path[b].x+","+path[b].y+"),"
                // }
                //     alert(s);
                // paths.push(path);

                // var s="";
                // for (var t=0;t<paths.length;t++) {
                //     var print = paths[t];
                //     for (var b = 0; b < print.length; b++) {
                //         s += "(" + print[b].x + "," + print[b].y + "),"
                //     }
                //     alert(s);
                //     s="";
                // }
                return Util.backtrace(paths);
            };

            module.exports = DepthFirstFinder;

        }, {"../core/DiagonalMovement": 3, "../core/Util": 7}],




        23: [function (_dereq_, module, exports) {


        }, {"../core/DiagonalMovement": 3, "../core/Heuristic": 5, "../core/Util": 7, "heap": 1}]
    }, {}, [8])
    (8)
});